package trans

/*
	Модуль предоставляет примитвы для симуляции транзисторов
	база -- логический вход (база транзистора). Может плавать, может иметь подтяжку к земле и питанию
	коллектор -- логический выход (инвертор). Если база не задана -- может плавать
	эмиттер -- логический выход (повторитель). Если нет сигнала на базе -- может плавать.
	---------
	Все входы выходы описываются тремя состояниями:
		уровень питания (1)
		уровень нуля (0)
		безразлично (-1)
*/

import (
	мФмт "fmt"
	мРнд "math/rand"
)

//ТТранс -- базовый тип для симуляции транзистора
type ТТранс struct {
	база         int8
	подтяж       int8 //Подяжка по базе
	кол          int8
	эм           int8
	истПодтяж    chan int8 //Запрос на получение значения подтяжки
	генПодтяж    chan int8 //Ответ на запрос на получение значения подтяжки
	истБаза      chan int8 //Запрос на получение значения базы
	генБаза      chan int8 //Ответ на запрос на получение базы
	истКол       chan int8 //Запрос на получение значения коллектора
	генКол       chan int8 //Ответ на запрос на получение значения коллектора
	истЭм        chan int8 //Запрос на получение эммитера
	генЭм        chan int8 //Ответ на запрос на получение значения эммитера
	истПодтяжУст chan int8 //Запрос на установку значения подтяжки
	истБазаУст   chan int8 //Запрос на установку значения базы
}

//ТрансНов -- возвращает указатель но новый ТТранс
func ТрансНов(пПодтяжка int8) (транс *ТТранс) {
	_транс := ТТранс{
		истПодтяж: make(chan int8),
		генПодтяж: make(chan int8),

		истБаза: make(chan int8),
		генБаза: make(chan int8),

		истКол: make(chan int8),
		генКол: make(chan int8),

		истЭм: make(chan int8),
		генЭм: make(chan int8),

		истПодтяжУст: make(chan int8),
		истБазаУст:   make(chan int8),
		база:         -1,
	}
	go _транс._Пуск()
	_транс.ПодтяжкаУст(пПодтяжка)
	return &_транс
}

//БазаУст -- устанавливает значение базы транзистора
func (сам *ТТранс) БазаУст(пЗнач int8) {
	if !(-1 <= пЗнач && пЗнач <= 1) {
		panic(мФмт.Errorf("ТТранс._БазаУст(): ФАТАЛЬНЫЙ СБОЙ пЗнач(%v) вне диапзона (-1...1)\n", пЗнач))
	}
	сам.истБазаУст <- пЗнач
}

//ПодтяжкаУст -- устанавливает подтяжку по базе
func (сам *ТТранс) ПодтяжкаУст(пПодтяж int8) {
	if !(-1 <= пПодтяж && пПодтяж <= 1) {
		panic(мФмт.Errorf("ТТранс.ПодтяжкаУст(): ФАТАЛЬНЫЙ СБОЙ пПодтяж(%v) вне диапзона (-1...1)\n", пПодтяж))
	}
	сам.истПодтяжУст <- пПодтяж
}

//База -- возвращает хранимое значение базы
func (сам *ТТранс) База() int8 {
	сам.истБаза <- 0
	return <-сам.генБаза
}

//Кол -- возвращает хранимое значение коллектора
func (сам *ТТранс) Кол() int8 {
	сам.истКол <- 1
	return <-сам.генКол
}

//Эм -- возвращает хранимое значение эммитера
func (сам *ТТранс) Эм() int8 {
	сам.истЭм <- 1
	return <-сам.генЭм
}

//Подтяжка -- возвращает хранимое значение подтяжки
func (сам *ТТранс) Подтяжка() int8 {
	сам.истПодтяж <- 1
	return <-сам.генПодтяж
}

func (сам *ТТранс) _Пуск() {
	for {
		select {
		case <-сам.истПодтяж: //Запрос на получение значения подтяжки
			сам.генПодтяж <- сам.подтяж
		case <-сам.истБаза: //Запрос на получение значения базы
			сам.генБаза <- сам.база
		case <-сам.истКол: //Запрос на получение коллектора
			сам.генКол <- сам.кол
		case <-сам.истЭм: //Запрос на получение значения эммитера
			сам.генЭм <- сам.эм
		case подтяж := <-сам.истПодтяжУст: //Запрос на установку подтяжки
			сам._ПодтяжУст(подтяж)
		case база := <-сам.истБазаУст: //Запрос на установку базы
			сам._БазаУст(база)
		}
	}
}

func (сам *ТТранс) _ПодтяжУст(пЗнач int8) {
	сам.подтяж = пЗнач
	if сам.база == -1 {
		сам._БазаУст(-1)
	}
}

func (сам *ТТранс) _БазаУст(пБаза int8) {
	сам.база = пБаза
	if сам.база == -1 && сам.подтяж == -1 {
		сам.база = int8(мРнд.Int31n(3))
		if сам.база == 2 {
			сам.база = -1
		}
	}
	switch сам.база {
	case 1:
		сам.кол = 0
		сам.эм = 1
	default:
		сам.кол = 1
		сам.эм = 0
	}
}
